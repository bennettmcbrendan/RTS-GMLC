---
title: "GeoDecomp Scheme Analysis"
author: "NREL"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  word_document:
    fig_caption: yes
    pandoc_args: ["--smart"]
    toc: yes
    toc_depth: 4
  html_document:
    toc: yes
    toc_depth: 4
params:
  Output.directory:
    label: Pick directory to drop csvs that are written out
    value: //plexossql/Data/bmcbenne/RTS-GMLC-decomp/RTS-GMLC/RTS_Data/FormattedData/PLEXOS/Analysis_scripts/csvs
  Solutions.directory:
    label: Pick directory with solutions (this should be fullpathto..HERE/Model ..
      Solution/.db)
    value: //plexossql/Data/bmcbenne/RTS-GMLC-decomp/RTS-GMLC/RTS_Data/FormattedData/PLEXOS/byGen/V7.4
    input: select
  intervals.per.day:
    choices:
    - 288
    - 96
    - 24
    input: select
    label: Intervals per day
    value: 288
  month:
    label: 'Month Range: (e.g., c(2:5) is Feb-May)'
    value: c(1:12)
always_allow_html: yes
---


```{r setOptions, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, cache=FALSE}

# load packages
pacman::p_load(gridExtra, rgdal, ggmap, Cairo, rgeos, maptools, lubridate, plyr, gdata, stringr, tidyr, rplexos, RSQLite, magrittr, dbplyr, lubridate, rmarkdown, scales, cowplot, data.table, fasttime,Hmisc, plotly, xtable, knitr, rmarkdown,grid,
               dplyr)

# Set up default options for chunks, turn off error or warning messages.
knitr::opts_chunk$set(cache = TRUE,
                      echo=FALSE, 
                      comment=NA, 
                      include = FALSE, 
                      warning=FALSE, 
                      error=TRUE, 
                      message=FALSE,
                      cache.lazy = FALSE,
                      dpi = 300,
                      dev=c('png','svg'), fig.keep = 'all', cache = TRUE)

theme_set(theme_bw())

output.dir = paste(params$Output.directory, sep = "/")
dir.create(output.dir, recursive = TRUE, showWarnings = FALSE)

solutions.dir = params$Solutions.directory


```


```{r query-inputs}

#------------------------------------------------------------------------------|
# input solution folders and scenario names ----
#------------------------------------------------------------------------------|

da.solutions = c('Model DAY_AHEAD Solution',
                 'Model DAY_AHEAD_A Solution',
                 'Model DAY_AHEAD_B1 Solution',
                 'Model DAY_AHEAD_B2 Solution',
                 'Model DAY_AHEAD_B3 Solution')

rt.solutions = c('Model REAL_TIME Solution',
                 'Model REAL_TIME_C Solution')

scenario.names.da <- c("Day Ahead MIP",
                        "Day Ahead LP",
                        "Day Ahead Region 1",
                        "Day Ahead Region 2",
                        "Day Ahead Region 3")

scenario.names.rt <- c("Real Time",
                        "Real Time Decomp")

scenario.order.da <- copy(scenario.names.da)
scenario.order.rt <- copy(scenario.names.rt)
    
scenario.colors <- c("Day Ahead MIP" = "#969696", 
                     "Day Ahead LP" = "#orange3",
                     "Day Ahead Region 1" = "skyblue",
                     "Day Ahead Region 2" = "steelblue3",
                     "Day Ahead Region 3" = "navyblue",
                     "Real Time" = "#969696", 
                     "Real Time Decomp" = "#orange3")

# # process plexos solutions with rplexos if not already done so ----
da.solution.paths <- sapply(da.solutions, function(x) file.path(solutions.dir,x))
rt.solution.paths <- sapply(rt.solutions, function(x) file.path(solutions.dir,x))

# paths to day ahead -rplexos.db
da.solution.dbs <- sapply(da.solution.paths, function(x){
  file.path(x, list.files(x, pattern = "-rplexos.db"))})

da.solution.logs <- sapply(da.solution.paths, function(x){
  file.path(x, list.files(x, pattern = "Log.txt"))})

print(paste("DA files exist?", file.exists(da.solution.dbs)))
# paths to real time -rplexos.db
rt.solution.dbs <- sapply(rt.solution.paths, function(x){
  file.path(x, list.files(x, pattern = "-rplexos.db"))})

rt.solution.logs <- sapply(rt.solution.paths, function(x){
  file.path(x, list.files(x, pattern = "Log.txt"))})

print(paste("RT files exist?", file.exists(rt.solution.dbs)))

# set column names for query tables
column.names <- c("scenario", "collection", 
                  "property", "unit", "name", "parent", 
                  "category", "time", "value")

#------------------------------------------------------------------------------|
# define sql query functions ----
#------------------------------------------------------------------------------|

# expand_time function
expand_time = function(data, db.path, phaseid = 4, look.ahead = 0) {
  setnames(data, "time_from", "time")
  data$time = ymd_hms(data$time)
  datadt = data.table(data, key = "key,time")
  
  # get time from database being queried
  timedt = data.table(tbl(src_sqlite(db.path), sql("SELECT * FROM time")) %>% 
                        filter(phase_id == phaseid) %>% collect())
  timedt$time = ymd_hms(timedt$time)  #R format time
  
  # drop extra look ahead days
  keep.days = unique(timedt[,.(day = floor_date(time, unit = "day"))])
  keep.days = keep.days[1:(nrow(keep.days) - look.ahead)]
  timedt = timedt[floor_date(time, unit = "day") %in% keep.days$day,]
  
  # Expand data
  cj2 = CJ(key = unique(datadt$key), time = timedt$time)
  cj3 = datadt[cj2, roll = TRUE]
  
  # Restore timezone (UTC)
  attributes(cj3$time) = attributes(timedt$time)
  cj3 = cj3[, `:=`(time_to, NULL)]
  
  cj3
}

# error handling function
error_handler <- function(query){
  result <- tryCatch(query,error = function(cond) { return('ERROR') } )
  if(class(result)[1] != "character"){
    if(nrow(result) == 0) {result <- 'ERROR'}
  }
  return(result)
}

```


```{r queries, eval = TRUE}

# if you have problems with query only taking first 100,000 lines, get latest version of Rcpp, dbplyr and dplyr.
# think it also may help to load dbplyr before dplyr

# 1) total generation

message('starting 1')

total.da.generation <- data.table()
  for(i in 1:length(scenario.names.da)){
    total.da.generation = error_handler(rbind(total.da.generation,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Generation'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }

total.rt.generation <- data.table()
  for(i in 1:length(scenario.names.rt)){
    total.rt.generation = error_handler(rbind(total.rt.generation,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Generation'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }

# 2) interval generation

message('starting 2')

 interval.da.generation <- data.table()
  
  for(i in 1:length(scenario.names.da)){
    
    interval.da.generation <- error_handler(rbind(interval.da.generation,
                        expand_time(data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_Generation 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                        collect(n = Inf)),da.solution.dbs[i])))
  }
 
  interval.rt.generation <- data.table()
  
  for(i in 1:length(scenario.names.rt)){
    
    interval.rt.generation <- error_handler(rbind(interval.rt.generation,
                        expand_time(data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_Generation 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                        collect()),rt.solution.dbs[i])))
  }

# 3) total available capacity

message('starting 3')

total.da.avail.cap <- data.table()
  for(i in 1:length(scenario.names.da)){
    total.da.avail.cap = error_handler(rbind(total.da.avail.cap,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Available Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }

total.rt.avail.cap <- data.table()
  for(i in 1:length(scenario.names.rt)){
    total.rt.avail.cap = error_handler(rbind(total.rt.avail.cap,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Available Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }

  

# 4) interval available capacity

message('starting 4')

 interval.da.avail.cap <- data.table()
  
  for(i in 1:length(scenario.names.da)){
    
    interval.da.avail.cap <- error_handler(rbind(interval.da.avail.cap,
                        expand_time(data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_AvailableCapacity 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                        collect(n = Inf)),da.solution.dbs[i])))
  }
 
  interval.rt.avail.cap <- data.table()
  
  for(i in 1:length(scenario.names.rt)){
    
    interval.rt.avail.cap <- error_handler(rbind(interval.rt.avail.cap,
                        expand_time(data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_AvailableCapacity 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                        collect(n = Inf)),rt.solution.dbs[i])))
  }


# 5) total production cost

message('starting 5')

total.da.cost <- data.table()
  for(i in 1:length(scenario.names.da)){
    total.da.cost = error_handler(rbind(total.da.cost,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Total Generation Cost'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }

total.rt.cost <- data.table()
  for(i in 1:length(scenario.names.rt)){
    total.rt.cost = error_handler(rbind(total.rt.cost,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Generator' AND property IS 'Total Generation Cost'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(c(column.names[-1],"region"))) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }

# 6) interval production cost

message('starting 6')

 interval.da.cost <- data.table()
  
  for(i in 1:length(scenario.names.da)){
    
    interval.da.cost <- error_handler(rbind(interval.da.cost,
                        expand_time(data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_GenerationCost 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                        collect(n = Inf)),da.solution.dbs[i])))
  }
 
  interval.rt.cost <- data.table()
  
  for(i in 1:length(scenario.names.rt)){
    
    interval.rt.cost <- error_handler(rbind(interval.rt.cost,
                        expand_time(data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                        FROM Generator_GenerationCost 
                        WHERE phase_id IS 4")) %>% 
                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                        collect(n = Inf)),rt.solution.dbs[i])))
  }


  # 7) total unserved energy
  
    total.da.use <- data.table()
  for(i in 1:length(scenario.names.da)){
     total.da.use <- error_handler(rbind(total.da.use,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Region' AND property IS 'Unserved Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }
    
    total.rt.use <- data.table()
  for(i in 1:length(scenario.names.rt)){
     total.rt.use <- error_handler(rbind(total.rt.use,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Region' AND property IS 'Unserved Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }
  
  
  # 8) total dump energy
  
   total.da.dump <- data.table()
  for(i in 1:length(scenario.names.da)){
     total.da.dump <- error_handler(rbind(total.da.dump,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Region' AND property IS 'Dump Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }
    
    total.rt.dump <- data.table()
  for(i in 1:length(scenario.names.rt)){
     total.rt.dump <- error_handler(rbind(total.rt.dump,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT * FROM year WHERE collection IS 
                                        'Region' AND property IS 'Dump Energy'")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }
    
    
    # 9) interval line flow
  
   interval.da.flow <- data.table()
  for(i in 1:length(scenario.names.da)){
     interval.da.flow <- error_handler(rbind(interval.da.flow,
                                        data.table(tbl(src_sqlite(da.solution.dbs[i]), 
                                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                                        FROM Line_Flow 
                                        WHERE phase_id IS 4")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.da[i]) %>% 
                                        collect(n = Inf))))
  }
    
    interval.rt.flow <- data.table()
  for(i in 1:length(scenario.names.rt)){
     interval.rt.flow <- error_handler(rbind(interval.rt.flow,
                                        data.table(tbl(src_sqlite(rt.solution.dbs[i]), 
                                        sql("SELECT key, name, category, time_from, time_to, value, property, region 
                                        FROM Line_Flow 
                                        WHERE phase_id IS 4")) %>% 
                                        filter(phase_id == 4) %>% select(one_of(column.names[-1])) %>% 
                                        dplyr::mutate(scenario = scenario.names.rt[i]) %>% 
                                        collect(n = Inf))))
  }

```


```{r metrics-table-rt, include=FALSE,eval = TRUE, fig.width=6, fig.height=3}


metrics.rt = total.rt.use[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value']

metrics.rt = merge(metrics.rt[,.(scenario,`Unserved Energy (GWh)` = value)],
                   total.rt.dump[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value'],
                   by = c('scenario'))

metrics.rt = merge(metrics.rt[,.(scenario,`Unserved Energy (GWh)`,`Dump Energy (GWh)` = value)],
                   total.rt.cost[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value'],
                   by = c('scenario'))

setnames(metrics.rt,'value','Total Cost (1000s)')

gen.table.rt = total.rt.generation[,lapply(.SD,sum),by=c('scenario','category'),.SDcols = 'value']
gen.table.rt[,category:=paste0(category,' (GWh)')]
gen.table.rt = data.table(dcast(gen.table.rt,
                                scenario ~ category,value.var = 'value'))

metrics.rt = merge(metrics.rt,gen.table.rt,by=c('scenario'))

for(i in 1:length(scenario.names.rt)){

    log.txt <- readLines(rt.solution.logs[i])
    log.txt <- log.txt[match(log.txt[grepl('<-- ST Schedule',log.txt)],
                             log.txt) + 1]
    log.txt = strsplit(log.txt,'Time: ')[[1]][2]
    
    metrics.rt[scenario == scenario.names.rt[i],Time:=log.txt]

}
    



```


```{r metrics-table-rt-print, include=TRUE,eval = TRUE, fig.width=6, fig.height=3}

kable(metrics.rt)


```




```{r metrics-table-da, include=FALSE,eval = TRUE, fig.width=6, fig.height=3}


metrics.da = total.da.use[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value']

metrics.da = merge(metrics.da[,.(scenario,`Unserved Energy (GWh)` = value)],
                   total.da.dump[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value'],
                   by = c('scenario'))

metrics.da = merge(metrics.da[,.(scenario,`Unserved Energy (GWh)`,`Dump Energy (GWh)` = value)],
                   total.da.cost[,lapply(.SD,sum),by=c('scenario'),.SDcols = 'value'],
                   by = c('scenario'))

setnames(metrics.da,'value','Total Cost (1000s)')

gen.table.da = total.da.generation[,lapply(.SD,sum),by=c('scenario','category'),.SDcols = 'value']
gen.table.da[,category:=paste0(category,' (GWh)')]
gen.table.da = data.table(dcast(gen.table.da,
                                scenario ~ category,value.var = 'value'))

metrics.da = merge(metrics.da,gen.table.da,by=c('scenario'))

for(i in 1:length(scenario.names.da)){

    log.txt <- readLines(da.solution.logs[i])
    log.txt <- log.txt[match(log.txt[grepl('FISCAL YEAR Text Solution Files Written',log.txt)],
                             log.txt) + 1]
    log.txt = strsplit(log.txt,'Time: ')[[1]][2]
    
    metrics.da[scenario == scenario.names.da[i],Time:=log.txt]

}

```


```{r metrics-table-da-print, include=TRUE,eval = TRUE, fig.width=6, fig.height=3}

kable(metrics.da)


```


```{r commit-plot, include=FALSE,eval = TRUE, fig.width=6, fig.height=3}


int.rt.gen = interval.rt.generation[grepl('Nuclear|Coal',category)]

int.rt.gen[,commit:= ifelse(value > 0.0001,100,0)]

int.commit = merge(int.rt.gen[scenario == 'Real Time Decomp',.(name,region,category,time,decomp.commit = commit)],
                   int.rt.gen[scenario == 'Real Time',.(name,region,category,time,normal.commit = commit)],
                   by = c('name','region','category','time'))

int.commit[,diff.commit:=ifelse(normal.commit == decomp.commit,0,100)]
int.commit[,month:=month.abb[month(time)]]

int.commit = int.commit[,lapply(.SD,mean),by = c('month','name','category'),
                        .SDcols = c("diff.commit","normal.commit","decomp.commit")]

int.commit$month = factor(int.commit$month,levels = month.abb)

p <- ggplot() + geom_bar(data = int.commit,aes(x = month,y = diff.commit),color = 'black',fill = 'steelblue3',
                         stat = 'identity') + 
      geom_line(data = int.commit,aes(x = month,y = normal.commit,group = 1),color = 'black') + 
      geom_line(data = int.commit,aes(x = month,y = decomp.commit,group = 1),color = 'firebrick') +
      facet_wrap(~name,scales = 'fixed') + 
      labs(x = 'month',y = 'Percent difference in commitment between GeoDecomp and SingleOpt')


```

```{r commit-plot-print, include=FALSE,eval = TRUE, fig.width = 9, fig.height=7}

p

```

```{r KSI-plot, include=FALSE,eval = TRUE, fig.width=6, fig.height=3}



```


